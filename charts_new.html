<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
    crossorigin="anonymous"></script>
</head>

<body>
  <div class="container-fluid">
    <div class="row m-2 mt-4">
      <div class="col-3">
        <div class="card m-0 shadow">
          <div class="m-2" id="device_list"></div>
        </div>
      </div>
      <div class="col-9" id="device_charts">
        <div class="card shadow">
          <h3 class="m-2">Графики</h3>
          <canvas></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    fetch('report-2023.04.07.txt')
      .then(response => response.text())
      .then(data => {
        // Разделяем содержимое файла на строки
        const lines = data.trim().split('\n');

        // Создаем объект, в котором будем хранить данные
        const result = {};

        // Проходим по каждой строке и преобразуем ее в желаемый формат
        lines.forEach(line => {
          const match = line.match(/^Zigbee2MQTT:info  (\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}): MQTT publish: topic 'zigbee2mqtt\/(.+):(.+)', payload '(.+)'/);

          if (match) {
            const [, date, time, model, serial, payloadStr] = match;

            try {
              const payload = JSON.parse(payloadStr);

              // Если такая модель еще не встречалась, создаем для нее новый объект
              if (!result[model]) {
                result[model] = {
                  model: model,
                  serial: {},
                  data: []
                };
              }

              // Если такой серийный номер еще не встречался, создаем для него новый объект
              if (!result[model].serial[serial]) {
                result[model].serial[serial] = {
                  date: [],
                  time: [],
                  linkquality: [],
                  temperature_temp1: [],
                  temperature_temp2: [],
                  zalupa: []
                };
              }

              // Добавляем данные в объект
              result[model].serial[serial].date.push(date);
              result[model].serial[serial].time.push(time);
              result[model].serial[serial].linkquality.push(payload.linkquality);
              result[model].serial[serial].temperature_temp1.push(payload.temperature_temp1);



              if (payload.temperature_temp2) {
                result[model].serial[serial].temperature_temp2.push(payload.temperature_temp2);
              }


              if (payload.zalupa) {
                result[model].serial[serial].zalupa.push(payload.zalupa);
              }
            } catch (error) {
              console.log(`Ошибка парсинга JSON в строке "${line}": ${error.message}`);
            }
          } else {
            console.log(`Строка "${line}" не соответствует формату`);
          }
        });

        const output = [];
        for (const [modelName, modelData] of Object.entries(result)) {
          for (const [serialNumber, serialData] of Object.entries(modelData.serial)) {
            const data = serialData.date.map((date, index) => {
              const datum = { date };
              if (serialData.time && serialData.time[index]) {
                datum.time = serialData.time[index];
              }
              if (serialData.linkquality && serialData.linkquality[index]) {
                datum.linkquality = serialData.linkquality[index];
              }
              if (serialData.temperature_temp1 && serialData.temperature_temp1[index]) {
                datum.temperature_temp1 = serialData.temperature_temp1[index];
              }
              if (serialData.temperature_temp2 && serialData.temperature_temp2[index]) {
                datum.temperature_temp2 = serialData.temperature_temp2[index];
              }
              if (serialData.zalupa && serialData.zalupa[index]) {
                datum.zalupa = serialData.zalupa[index];
              }
              return datum;
            });
            output.push({
              model: modelData.model,
              serial: serialNumber,
              data,
            });
          }
        }

        // console.log(output);

        // Получаем количество устройств и их общий список:
        function getModelSerialCount(output) {
          const modelSerialSet = new Set();
          output.forEach(item => {
            const modelSerial = `${item.model}_${item.serial}`;
            modelSerialSet.add(modelSerial);
          });

          return {
            count: modelSerialSet.size,
            modelSerials: [...modelSerialSet]
          };
        }
        const { count, modelSerials } = getModelSerialCount(output);
        // console.log(count);
        // console.log(modelSerials);





        // Получение контекста для работы с графиками:
        let canvas = window.document.querySelector('canvas');
        let context = canvas.getContext('2d');
        let chart = null;

        // :
        const createLineChart = (label, xData, yData, linkquality) => {
          let gradient = context.createLinearGradient(0, 0, 0, window.screen.width / 2);
          gradient.addColorStop(0, 'rgba(20, 160, 200, 0.7)');
          gradient.addColorStop(1, 'rgba(20, 160, 200, 0.001)');

          let datas321 = {
            labels: xData,
            datasets: [{
              label: label,
              data: yData,
              pointStyle: false,
              fill: false,
              backgroundColor: gradient,
              borderWidth: 2,
              borderColor: 'rgba(20, 160, 200, 1)',
              tension: 0.4 // Степень натяжения для кривой-Безье.
            },
            // {
            //   label: label,
            //   data: linkquality
            // }
            ]
          }

          // Настройки горизонтальной оси-X (дата-время):
          let xScaleConfig = {
            // min: 0,
            // max: 50,
            ticks: {
              autoSkip: true, // .
              minRotation: 30, // Минимальный наклон.
              maxRotation: 60, // Максимальный наклон.
              // color: 'rgba(20, 160, 200, 0.7)' // Цвет текста.
            },
            border: {
              // color: 'rgba(20, 160, 200, 1)' // Цвет нижней линии.
            },
            grid: {
              // color: 'rgba(20, 160, 200, 0.3)' // Цвет вертикальных линий сетки.
            }
          }

          // Настройки всех линий данных оси-Y (может быть много):
          let yScaleConfig = {
            ticks: {
              // color: 'rgba(20, 160, 200, 0.7)' // Цвет текста.
            },
            border: {
              // color: 'rgba(20, 160, 200, 1)' // Цвет нижней линии.
            },
            grid: {
              // color: 'rgba(20, 160, 200, 0.3)' // Цвет вертикальных линий сетки.
            }
          }

          let config = {
            type: 'line',
            data: datas321,
            options: {
              scales: {
                x: xScaleConfig,
                y: yScaleConfig
              },
              plugins: {
                legend: {
                  display: true // Отображение легенды.
                }
              }
            }
          }

          chart = new Chart(context, config);
        }

        // Функции для работы с графиками:
        const draWWW = (index) => {
          console.log(output[index]);

          let datas123 = output[index].data;
          let xData = [];
          let yData = [];
          let linkquality1 = [];

          // Дописываем данные, количество i - количество отображаемых записей:
          // for (let i = 0; i < 100; i++) {
          for (let i = 0; i < datas123.length; i++) {
            // console.log(`x=${datas123[i].time}, y=${datas123[i].temperature_temp1}`);
            // xData.push(`${datas123[i].date} ${datas123[i].time}`);
            xData.push(`${datas123[i].time}`);
            yData.push(datas123[i].temperature_temp1);
            linkquality1.push(datas123[i].linkquality);
          }

          createLineChart(
            `${output[index].model}:${output[index].serial}`,
            xData,
            yData,
            linkquality1
          );
        };















        // Построение списка всех преобразованных устройств из лог-файла:
        function createDeviceList(modelSerials) {
          const deviceList = document.createElement('ul');
          deviceList.className = 'list-group';

          modelSerials.forEach((modelSerial, index) => {
            const [model, serial] = modelSerial.split('_');
            const listItem = document.createElement('li');
            listItem.className = 'list-group-item';

            const radioInput = document.createElement('input');
            radioInput.type = 'radio';
            radioInput.name = 'device';
            radioInput.value = index;
            radioInput.className = 'form-check-input';

            radioInput.addEventListener('click', () => draWWW(index));

            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.textContent = `${model} ${serial}`;
            label.prepend(radioInput);
            listItem.append(label);
            deviceList.append(listItem);
          });

          const deviceCount = document.createElement('h5');
          deviceCount.className = ''; // заменить на нормальный класс?
          deviceCount.textContent = `Количество опознанных устройств: ${modelSerials.length}`;

          const container = document.getElementById('device_list');
          container.append(deviceCount, deviceList);
        }

        createDeviceList(modelSerials);
      })
      .catch(error => console.error(error));

  </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <style>

    </style>
</head>

<body>
    <style>
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.5s ease;
        }

        .loading-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100px;
            height: 50px;
        }

        .circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            margin: 0 5px;
            animation: bounce 1.5s infinite ease-in-out;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(-25px);
            }

            50% {
                transform: translateY(0);
            }
        }

        .loading-icon .circle:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-icon .circle:nth-child(2) {
            animation-delay: -0.16s;
        }

        .loading-icon .circle:nth-child(3) {
            animation-delay: 0s;
        }

        .loading-icon .circle.at {
            background-color: #00bfff;
        }

        #loading-overlay.active {
            visibility: visible;
            opacity: 1;
        }
    </style>
    <div id="loading-overlay">
        <div class="loading-icon">
            <div class="circle"></div>
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var loadingOverlay = document.getElementById("loading-overlay");
            var circles = loadingOverlay.getElementsByClassName("circle");
            var randomCircle = circles[Math.floor(Math.random() * circles.length)];
            randomCircle.classList.add("at");

            window.addEventListener("load", function () {
                loadingOverlay.classList.add("active");
                setTimeout(function () {
                    loadingOverlay.style.display = "none";
                }, 3500);
            });
        });
    </script>


    <h1>Input Storage</h1>
    <form id="vhodi-form">
        <label>Text input:</label>
        <input data-save="true" type="text" id="text-input1" />
        <input data-save="true" type="text" id="text-input2" />
        <input data-save="true" type="text" id="text-input3" value="!This value will not be saved">
    </form>
    <form>
        <label>Checkbox:</label>
        <input type="checkbox" id="checkbox-input1" data-save="true" />
        <input type="checkbox" id="checkbox-input2" data-save="true" />
        <input type="checkbox" id="checkbox-input3" data-save="true" />
        <input type="checkbox" id="checkbox-input4" data-save="true" />
        <input type="checkbox" id="checkbox-input5" data-save="true" />
    </form>
    <p>
        <label>Radio 1:</label>
        <input type="radio" name="radioinput" id="radio-input-1" value="" data-save="true" />
        <label>Radio 2:</label>
        <input type="radio" name="radioinput" id="radio-input-2" value="" data-save="true" />
        <label>Radio 3:</label>
        <input type="radio" name="radioinput" id="radio-input-3" value="" data-save="true" />
        <label>Radio 4:</label>
        <input type="radio" name="radioinput" id="radio-input-4" value="" data-save="true" />
    </p>
    <form name="polzuli">
        <label>Range:</label>
        <input type="range" id="range-input1" data-save="true" />
        <input type="range" id="range-input2" data-save="true" />
    </form>
    <p>
        <label>Button:</label>
        <button id="button-input">Click me</button>
    </p>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"
        integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
        crossorigin="anonymous"></script>

    <!-- https://cdnjs.com/libraries/crypto-js -->
    <script src="js/crypto-js.min@4.1.1.js"></script>

    <!--  -->
    <script>
        // Функция для проверки, посещал ли пользователь ранее этот ресурс. 
        function checkVisited() {
            if (!localStorage.getItem('visited-page')) {
                localStorage.setItem('visited-page', true); // Если нет, записываем это в localstorage.
            }
        }
        checkVisited();


        // ВСЁ ЧТО НИЖЕ - ТОЧНО РАБОТАЕТ!!! но нужно немного тестов...

        // Секретный ключ для шифрования данных в Local Storage. Обычно его длина составляет от 32 до 128 символов. 
        // Рекомендуется использовать случайные символы, такие как буквы (верхнего и нижнего регистра), цифры и специальные символы.
        const secretKey = 'Да что ж такое то блять, то одно, то другое.. то - одно блять, то - другое!';
        // const value = 'Какой-то рандомный текст для тестов!';

        // const encryptedValue = encryptValue(value, secretKey);
        // console.log('Encrypted value:', encryptedValue);

        // const decryptedValue = decryptValue(encryptedValue, secretKey);
        // console.log('Decrypted value:', decryptedValue);


        function encryptValue(value, secretKey) {
            const cipherText = CryptoJS.AES.encrypt(value, secretKey);
            return cipherText.toString();
        }

        function decryptValue(value, secretKey) {
            CryptoJS.AES.decrypt(value, secretKey).bytes.toString(CryptoJS.enc.Utf8);
            return decipheredText;
        }

        function save_input_to_local_storage(input_element) {
            // получаем значение атрибута 'data-save' у input элемента
            const save = input_element.getAttribute("data-save");

            // если значение атрибута равно null или 'false', значит сохранение не требуется
            if (save === null || save === "false") {
                // получаем ключ из id или name элемента
                const key = input_element.id || input_element.name;

                // проверяем, есть ли сохраненное значение по ключу, и если есть - удаляем его из localStorage
                const storedValue = localStorage.getItem(key);
                if (storedValue !== null) {
                    localStorage.removeItem(key);
                }
            }
            // если значение атрибута равно 'true', значит нужно сохранить значение элемента в localStorage
            else {
                // получаем значение элемента в зависимости от типа (для чекбоксов и радиокнопок - checked, для остальных - value)
                const value =
                    input_element.type === "checkbox" || input_element.type === "radio"
                        ? input_element.checked
                        : input_element.value;

                // получаем родительскую форму элемента
                const formElement = input_element.closest("form");

                // устанавливаем префикс ключа в зависимости от наличия родительской формы и типа элемента
                let keyPrefix = "";
                if (formElement) {
                    // если есть родительская форма, то префикс - ее id или name с символом "_"
                    keyPrefix = (formElement.id || formElement.name) + "_";
                } else {
                    // если нет родительской формы, то префикс - 'bool_', 'num_' или 'text_' в зависимости от типа элемента
                    if (input_element.type === "checkbox" || input_element.type === "radio") {
                        keyPrefix = "bool_";
                    } else if (!Number.isNaN(Number(input_element.value))) {
                        keyPrefix = "num_";
                    } else {
                        keyPrefix = "text_";
                    }
                }

                // создаем ключ из префикса и id или name элемента
                const key = keyPrefix + (input_element.id || input_element.name);

                // сохраняем значение элемента в localStorage, преобразуя его в строку JSON
                // localStorage.setItem(key, JSON.stringify(encryptValue(value, secretKey)));            
                localStorage.setItem(key, JSON.stringify(value));
                console.log('Туда в крипту: ', value);
            }
        }

        function load_input_from_local_storage(input_element) {
            // получаем значение атрибута 'data-save' у input элемента
            const save = input_element.getAttribute("data-save");

            // получаем ключ из id или name элемента
            const key = input_element.id || input_element.name;

            // получаем родительскую форму элемента
            const formElement = input_element.closest("form");

            // устанавливаем префикс ключа в зависимости от наличия родительской формы и типа элемента
            let keyPrefix = "";
            if (formElement) {
                // если есть родительская форма, то префикс - ее id или name с символом "_"
                keyPrefix = (formElement.id || formElement.name) + "_";
            } else {
                // если нет родительской формы, то префикс - 'bool_', 'num_' или 'text_' в зависимости от типа элемента
                if (input_element.type === "checkbox" || input_element.type === "radio") {
                    keyPrefix = "bool_";
                } else if (!Number.isNaN(Number(input_element.value))) {
                    keyPrefix = "num_";
                } else {
                    keyPrefix = "text_";
                }
            }

            // создаем ключ из префикса и id или name элемента
            const prefixedKey = keyPrefix + key;

            // если значение атрибута равно null или 'false', значит сохранение не требуется
            if (save === null || save === "false") {
                // проверяем, есть ли сохраненное значение по ключу с префиксом
                const storedValue = localStorage.getItem(prefixedKey);
                if (storedValue !== null) {
                    // удаляем сохраненное значение по ключу с префиксом
                    localStorage.removeItem(prefixedKey);
                }
            }
            // если значение атрибута равно 'true', значит нужно загрузить значение элемента из localStorage
            else {
                // проверяем, есть ли сохраненное значение по ключу с префиксом
                const storedValue = localStorage.getItem(prefixedKey);
                if (storedValue !== null) {
                    // расшифровываем значение из JSON и сохраняем его в переменную
                    let decryptedValue;
                    try {
                        decryptedValue = JSON.parse(storedValue);
                        // decryptedValue = JSON.parse(decryptValue(storedValue, secretKey));
                        console.log('Сюда после крипты: ', decryptedValue);
                    } catch (error) {
                        decryptedValue = null;
                    }

                    // устанавливаем значение элемента
                    if (decryptedValue !== null) {
                        if (input_element.type === "checkbox" || input_element.type === "radio") {
                            // для checkbox и radio элементов значение должно быть true или false
                            input_element.checked = decryptedValue === true;
                        } else {
                            // для других элементов значение должно быть строкой или числом
                            input_element.value = decryptedValue;
                        }
                    }
                }
            }
        }






        // обработчик события загрузки страницы
        window.addEventListener("load", function () {
            // получаем все input элементы на странице
            const inputElements = document.querySelectorAll("input");

            // для каждого input элемента вызываем функцию load_input_from_local_storage
            inputElements.forEach(function (inputElement) {
                load_input_from_local_storage(inputElement);
            });
        });


        document.querySelectorAll('input').forEach((input) => {
            input.addEventListener('input', () => {
                save_input_to_local_storage(input);
                console.log('Демон изменения inputs: ', input.id);
                // console.log('',);
            });
        });

        // Выводим хранилище в консоль:
        // localStorage.clear();
        for (var key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                console.log(key + ': ' + localStorage.getItem(key) + '\n');

            }
        }


        /*
        В целом, этот код может быть улучшен, например:
        1/ Разбить функции save_input_to_local_storage и load_input_from_local_storage на более мелкие и читабельные функции с более точными именами.
        2/ Реализовать функции без использования глобальных переменных. Вместо этого, можно передавать значения в качестве аргументов и возвращать 
        результаты, а также использовать локальные переменные.
        3/ Разделить логику функции load_input_from_local_storage на две части: первая часть должна получать значения из localStorage и расшифровывать их с 
        использованием SECRET_KEY, а вторая часть должна устанавливать значения в элементы формы. Это позволит легче поддерживать код и делает его более читабельным.
        4/ Добавить обработку ошибок, например, если при расшифровке данных из localStorage произошла ошибка, то нужно с
        
        
        Код может быть улучшен в нескольких аспектах:
        1/ Использовать более эффективный алгоритм скрытия и отображения интерфейса. Вместо добавления класса "hidden" для каждого элемента, можно добавить этот класс 
        только для родительского элемента и использовать CSS-селекторы, чтобы скрыть все вложенные элементы.
        2/ Использовать асинхронный подход для загрузки данных из локального хранилища, чтобы не блокировать интерфейс пользователя во время загрузки.
        3/ Добавить проверку наличия значения в локальном хранилище перед восстановлением значения, чтобы не затирать значения, которые пользователь уже ввел в форму.
        4/ Добавить возможность настройки ключа шифрования, чтобы пользователь мог задать свой собственный ключ.
        5/ Добавить обработку ошибок, чтобы при возникновении ошибок в работе функций пользователь получал понятное сообщение об ошибке.
        6/ Оптимизировать код для уменьшения его размера и повышения производительности. Например, можно использовать более короткие имена переменных, убрать лишние 
        проверки и т.д.
        
        
        
    
        
        */
    </script>




</body>

</html>
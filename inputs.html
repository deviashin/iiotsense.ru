<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <style>

    </style>
</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="290px" height="256px" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
    viewBox="0 0 15.09 13.32"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:xodm="http://www.corel.com/coreldraw/odm/2003">
        <defs>
            <style type="text/css">
                <!-- .str0 {
                    stroke: #212227;
                    stroke-width: 0.2;
                    stroke-miterlimit: 22.9256;
                } -->

                .str0 {
                    stroke: #212227;
                    stroke-width: 0.2;
                }
                .fil0 {
                    fill: none;
                }

                .flame {
                    animation-name: flame;
                    animation-duration: 4s;
                    animation-timing-function: linear;
                    animation-iteration-count: infinite;
                  }
                  
                  @keyframes flame {
                    0% {
                      stroke-dasharray: 0 40;
                      stroke-dashoffset: 0;
                    }
                    50% {
                      stroke-dasharray: 20 40;
                      stroke-dashoffset: 0;
                    }
                    100% {
                      stroke-dasharray: 20 40;
                      stroke-dashoffset: -40;
                    }
                  }
                  
            </style>
        </defs>
        <!-- <path class="fil0 str0 flame" -->
            <!-- d="M10.71 5.38l5.88 5.88c0.45,0.45 0.59,1.08 0.44,1.65l0.17 0.16 1.2 1.2 0 2.41 -5.75 5.75 -2.41 0 -1.2 -1.21 -0.61 0.61 -8.29 -8.29 2.41 -2.41 8.29 8.29 -0.6 0.6 0.6 0.6 1.21 0 4.54 -4.54 0 -1.21 -0.6 -0.6 -0.16 -0.16c-0.57,0.15 -1.2,0 -1.64,-0.44l-5.89 -5.88c-0.66,-0.66 -0.66,-1.75 0,-2.41 0.66,-0.66 1.75,-0.66 2.41,0z" /> -->
        <!-- <path class="fil0 str0 flame" -->
            <!-- d="M14.19 1.91l5.88 5.88c0.66,0.66 0.66,1.74 0,2.4 -0.66,0.67 -1.74,0.67 -2.41,0l-5.88 -5.88c-0.44,-0.44 -0.59,-1.07 -0.44,-1.64l-0.16 -0.16 -0.61 -0.6 -1.2 0 -4.55 4.54 0 1.2 0.61 0.61 0.16 0.16c0.57,-0.15 1.2,-0.01 1.64,0.44l5.89 5.88c0.66,0.66 0.66,1.74 0,2.41 -0.67,0.66 -1.75,0.66 -2.41,0l-5.89 -5.89c-0.44,-0.44 -0.59,-1.07 -0.44,-1.64l-0.16 -0.16 -1.2 -1.2 0 -2.41 5.75 -5.75 2.41 0 1.2 1.2 0.16 0.17c0.57,-0.15 1.2,-0.01 1.65,0.44z" /> -->
            <path class="fil0 str0 flame" d="M15.07 7.02c-0.09,-1.01 -0.26,-1.72 -0.63,-2.55 -0.16,-0.36 -0.36,-0.71 -0.55,-1.02 -0.1,-0.16 -0.21,-0.29 -0.32,-0.45 -0.12,-0.16 -0.24,-0.29 -0.36,-0.44 -0.15,-0.19 -0.21,-0.22 -0.38,-0.39 -0.35,-0.37 -0.88,-0.78 -1.32,-1.05 -3.78,-2.29 -8.59,-0.93 -10.62,2.84 -0.8,1.49 -1.12,3.36 -0.71,5.26 0.26,1.22 1.27,3.24 2.39,3.9 0.87,0.51 1.76,-0.04 2.06,-0.67 0.49,-1.02 -0.3,-1.65 -0.68,-2.17 -2.23,-3.04 -0.18,-7.16 3.48,-7.24 1.99,-0.04 3.36,1.08 4.04,2.26 1.55,2.71 -0.37,5.58 -1.09,5.57 -0.16,0 -0.73,-0.28 -0.17,-0.9 1.79,-1.98 0.88,-5.15 -1.66,-5.9 -1.98,-0.58 -3.59,0.65 -4.19,1.83 -0.61,1.19 -0.58,2.51 0.2,3.66 0.2,0.3 0.48,0.74 0.86,0.68 0.43,-0.07 0.62,-0.59 0.3,-0.93 -0.25,-0.27 -0.44,-0.55 -0.59,-0.98 -0.3,-0.9 -0.01,-1.94 0.48,-2.46 1.24,-1.34 3.3,-1.1 4.15,0.41 0.43,0.77 0.44,1.75 0,2.51 -0.35,0.61 -1.18,1.13 -0.73,2.21 0.27,0.66 1.12,1.22 2.01,0.76 0.6,-0.3 1.13,-1 1.47,-1.68 1.58,-3.14 -0.06,-6.96 -3.47,-7.91 -1.92,-0.53 -3.74,0.04 -4.92,0.98 -0.21,0.17 -0.65,0.56 -0.82,0.76 -0.77,0.97 -1.29,2.02 -1.33,3.4 -0.05,1.26 0.37,2.73 1.14,3.59 0.17,0.19 0.63,0.58 0.6,0.97 -0.01,0.27 -0.38,0.65 -0.93,0.11 -0.7,-0.69 -1.38,-2.09 -1.6,-3.12 -0.71,-3.38 1.36,-6.68 4.72,-7.6 1.83,-0.5 3.78,-0.05 5.1,0.79 3.36,2.14 4.01,6.68 1.53,9.63 -0.32,0.38 -0.67,0.59 -0.51,1 0.07,0.17 0.21,0.31 0.44,0.34 0.35,0.05 0.68,-0.42 0.89,-0.67 1.07,-1.26 1.89,-3.36 1.72,-5.33z"/>
        </svg>



    <style>
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.5s ease;
        }

        .loading-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100px;
            height: 50px;
        }

        .circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #333;
            margin: 0 5px;
            animation: bounce 1.5s infinite ease-in-out;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(-25px);
            }

            50% {
                transform: translateY(0);
            }
        }

        .loading-icon .circle:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-icon .circle:nth-child(2) {
            animation-delay: -0.16s;
        }

        .loading-icon .circle:nth-child(3) {
            animation-delay: 0s;
        }

        .loading-icon .circle.at {
            background-color: #00bfff;
        }

        #loading-overlay.active {
            visibility: visible;
            opacity: 1;
        }
    </style>
    <div id="loading-overlay">
        <div class="loading-icon">
            <div class="circle"></div>
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var loadingOverlay = document.getElementById("loading-overlay");
            var circles = loadingOverlay.getElementsByClassName("circle");
            var randomCircle = circles[Math.floor(Math.random() * circles.length)];
            randomCircle.classList.add("at");

            window.addEventListener("load", function () {
                loadingOverlay.classList.add("active");
                setTimeout(function () {
                    loadingOverlay.style.display = "none";
                }, 3500);
            });
        });
    </script>


    <h1>Input Storage</h1>
    <form id="vhodi-form">
        <label>Text input:</label>
        <input data-save="true" type="text" id="text-input1" />
        <input data-save="true" type="text" id="text-input2" />
        <input data-save="true" type="text" id="text-input3" value="!This value will not be saved">
    </form>
    <form>
        <label>Checkbox:</label>
        <input type="checkbox" id="checkbox-input1" data-save="true" />
        <input type="checkbox" id="checkbox-input2" data-save="true" />
        <input type="checkbox" id="checkbox-input3" data-save="true" />
        <input type="checkbox" id="checkbox-input4" data-save="true" />
        <input type="checkbox" id="checkbox-input5" data-save="true" />
    </form>
    <p>
        <label>Radio 1:</label>
        <input type="radio" name="radioinput" id="radio-input-1" value="" data-save="true" />
        <label>Radio 2:</label>
        <input type="radio" name="radioinput" id="radio-input-2" value="" data-save="true" />
        <label>Radio 3:</label>
        <input type="radio" name="radioinput" id="radio-input-3" value="" data-save="true" />
        <label>Radio 4:</label>
        <input type="radio" name="radioinput" id="radio-input-4" value="" data-save="true" />
    </p>
    <form name="polzuli">
        <label>Range:</label>
        <input type="range" id="range-input1" data-save="true" />
        <input type="range" id="range-input2" data-save="true" />
    </form>
    <p>
        <label>Button:</label>
        <button id="button-input">Click me</button>
    </p>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"
        integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
        crossorigin="anonymous"></script>

    <!-- https://cdnjs.com/libraries/crypto-js -->
    <script src="js/crypto-js.min@4.1.1.js"></script>

    <!--  -->
    <script>
        // Функция для проверки, посещал ли пользователь ранее этот ресурс. 
        function checkVisited() {
            if (!localStorage.getItem('visited-page')) {
                localStorage.setItem('visited-page', true); // Если нет, записываем это в localstorage.
            }
        }
        checkVisited();


        // ВСЁ ЧТО НИЖЕ - ТОЧНО РАБОТАЕТ!!! но нужно немного тестов...

        // Секретный ключ для шифрования данных в Local Storage. Обычно его длина составляет от 32 до 128 символов. 
        // Рекомендуется использовать случайные символы, такие как буквы (верхнего и нижнего регистра), цифры и специальные символы.
        const secretKey = 'Да что ж такое то блять, то одно, то другое.. то - одно блять, то - другое!';
        // const value = 'Какой-то рандомный текст для тестов!';

        // const encryptedValue = encryptValue(value, secretKey);
        // console.log('Encrypted value:', encryptedValue);

        // const decryptedValue = decryptValue(encryptedValue, secretKey);
        // console.log('Decrypted value:', decryptedValue);


        function encryptValue(value, secretKey) {
            const cipherText = CryptoJS.AES.encrypt(value, secretKey);
            return cipherText.toString();
        }

        function decryptValue(value, secretKey) {
            CryptoJS.AES.decrypt(value, secretKey).bytes.toString(CryptoJS.enc.Utf8);
            return decipheredText;
        }

        function save_input_to_local_storage(input_element) {
            // получаем значение атрибута 'data-save' у input элемента
            const save = input_element.getAttribute("data-save");

            // если значение атрибута равно null или 'false', значит сохранение не требуется
            if (save === null || save === "false") {
                // получаем ключ из id или name элемента
                const key = input_element.id || input_element.name;

                // проверяем, есть ли сохраненное значение по ключу, и если есть - удаляем его из localStorage
                const storedValue = localStorage.getItem(key);
                if (storedValue !== null) {
                    localStorage.removeItem(key);
                }
            }
            // если значение атрибута равно 'true', значит нужно сохранить значение элемента в localStorage
            else {
                // получаем значение элемента в зависимости от типа (для чекбоксов и радиокнопок - checked, для остальных - value)
                const value =
                    input_element.type === "checkbox" || input_element.type === "radio"
                        ? input_element.checked
                        : input_element.value;

                // получаем родительскую форму элемента
                const formElement = input_element.closest("form");

                // устанавливаем префикс ключа в зависимости от наличия родительской формы и типа элемента
                let keyPrefix = "";
                if (formElement) {
                    // если есть родительская форма, то префикс - ее id или name с символом "_"
                    keyPrefix = (formElement.id || formElement.name) + "_";
                } else {
                    // если нет родительской формы, то префикс - 'bool_', 'num_' или 'text_' в зависимости от типа элемента
                    if (input_element.type === "checkbox" || input_element.type === "radio") {
                        keyPrefix = "bool_";
                    } else if (!Number.isNaN(Number(input_element.value))) {
                        keyPrefix = "num_";
                    } else {
                        keyPrefix = "text_";
                    }
                }

                // создаем ключ из префикса и id или name элемента
                const key = keyPrefix + (input_element.id || input_element.name);

                // сохраняем значение элемента в localStorage, преобразуя его в строку JSON
                // localStorage.setItem(key, JSON.stringify(encryptValue(value, secretKey)));            
                localStorage.setItem(key, JSON.stringify(value));
                console.log('Туда в крипту: ', value);
            }
        }

        function load_input_from_local_storage(input_element) {
            // получаем значение атрибута 'data-save' у input элемента
            const save = input_element.getAttribute("data-save");

            // получаем ключ из id или name элемента
            const key = input_element.id || input_element.name;

            // получаем родительскую форму элемента
            const formElement = input_element.closest("form");

            // устанавливаем префикс ключа в зависимости от наличия родительской формы и типа элемента
            let keyPrefix = "";
            if (formElement) {
                // если есть родительская форма, то префикс - ее id или name с символом "_"
                keyPrefix = (formElement.id || formElement.name) + "_";
            } else {
                // если нет родительской формы, то префикс - 'bool_', 'num_' или 'text_' в зависимости от типа элемента
                if (input_element.type === "checkbox" || input_element.type === "radio") {
                    keyPrefix = "bool_";
                } else if (!Number.isNaN(Number(input_element.value))) {
                    keyPrefix = "num_";
                } else {
                    keyPrefix = "text_";
                }
            }

            // создаем ключ из префикса и id или name элемента
            const prefixedKey = keyPrefix + key;

            // если значение атрибута равно null или 'false', значит сохранение не требуется
            if (save === null || save === "false") {
                // проверяем, есть ли сохраненное значение по ключу с префиксом
                const storedValue = localStorage.getItem(prefixedKey);
                if (storedValue !== null) {
                    // удаляем сохраненное значение по ключу с префиксом
                    localStorage.removeItem(prefixedKey);
                }
            }
            // если значение атрибута равно 'true', значит нужно загрузить значение элемента из localStorage
            else {
                // проверяем, есть ли сохраненное значение по ключу с префиксом
                const storedValue = localStorage.getItem(prefixedKey);
                if (storedValue !== null) {
                    // расшифровываем значение из JSON и сохраняем его в переменную
                    let decryptedValue;
                    try {
                        decryptedValue = JSON.parse(storedValue);
                        // decryptedValue = JSON.parse(decryptValue(storedValue, secretKey));
                        console.log('Сюда после крипты: ', decryptedValue);
                    } catch (error) {
                        decryptedValue = null;
                    }

                    // устанавливаем значение элемента
                    if (decryptedValue !== null) {
                        if (input_element.type === "checkbox" || input_element.type === "radio") {
                            // для checkbox и radio элементов значение должно быть true или false
                            input_element.checked = decryptedValue === true;
                        } else {
                            // для других элементов значение должно быть строкой или числом
                            input_element.value = decryptedValue;
                        }
                    }
                }
            }
        }






        // обработчик события загрузки страницы
        window.addEventListener("load", function () {
            // получаем все input элементы на странице
            const inputElements = document.querySelectorAll("input");

            // для каждого input элемента вызываем функцию load_input_from_local_storage
            inputElements.forEach(function (inputElement) {
                load_input_from_local_storage(inputElement);
            });
        });


        document.querySelectorAll('input').forEach((input) => {
            input.addEventListener('input', () => {
                save_input_to_local_storage(input);
                console.log('Демон изменения inputs: ', input.id);
                // console.log('',);
            });
        });

        // Выводим хранилище в консоль:
        // localStorage.clear();
        for (var key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                console.log(key + ': ' + localStorage.getItem(key) + '\n');

            }
        }


        /*
        В целом, этот код может быть улучшен, например:
        1/ Разбить функции save_input_to_local_storage и load_input_from_local_storage на более мелкие и читабельные функции с более точными именами.
        2/ Реализовать функции без использования глобальных переменных. Вместо этого, можно передавать значения в качестве аргументов и возвращать 
        результаты, а также использовать локальные переменные.
        3/ Разделить логику функции load_input_from_local_storage на две части: первая часть должна получать значения из localStorage и расшифровывать их с 
        использованием SECRET_KEY, а вторая часть должна устанавливать значения в элементы формы. Это позволит легче поддерживать код и делает его более читабельным.
        4/ Добавить обработку ошибок, например, если при расшифровке данных из localStorage произошла ошибка, то нужно с
        
        
        Код может быть улучшен в нескольких аспектах:
        1/ Использовать более эффективный алгоритм скрытия и отображения интерфейса. Вместо добавления класса "hidden" для каждого элемента, можно добавить этот класс 
        только для родительского элемента и использовать CSS-селекторы, чтобы скрыть все вложенные элементы.
        2/ Использовать асинхронный подход для загрузки данных из локального хранилища, чтобы не блокировать интерфейс пользователя во время загрузки.
        3/ Добавить проверку наличия значения в локальном хранилище перед восстановлением значения, чтобы не затирать значения, которые пользователь уже ввел в форму.
        4/ Добавить возможность настройки ключа шифрования, чтобы пользователь мог задать свой собственный ключ.
        5/ Добавить обработку ошибок, чтобы при возникновении ошибок в работе функций пользователь получал понятное сообщение об ошибке.
        6/ Оптимизировать код для уменьшения его размера и повышения производительности. Например, можно использовать более короткие имена переменных, убрать лишние 
        проверки и т.д.
        
        
        
    
        
        */
    </script>




</body>

</html>